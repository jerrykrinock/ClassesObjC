#import "SSYMOCManager.h"
#import "NSError+Recovery.h"
#import "NSError+MyDomain.h"
#import "NSString+MorePaths.h"
#import "NSString+LocalizeSSY.h"
#import "NSError+InfoAccess.h"
#import "NSBundle+MainApp.h"
#import "NSManagedObjectContext+Cheats.h"
#import "NSError+DecodeCodes.h"
#import "NSObject+MoreDescriptions.h"
#import "NSBundle+SSYMotherApp.h"
#import "NSBundle+MainApp.h"
#import "NSDictionary+SimpleMutations.h"
#import "NSManagedObject+SSYCopying.h"
#import "BSManagedDocument.h"
/* BSManagedDocument is a open source replacement for NSPersistentDocument.
 It is recommended for any Core Data document-based app.
 https://github.com/jerrykrinock/BSManagedDocument
 
 Objective-C declaration for SSYMOCManager+Swift.h, which must be compiled
 in your target.  The normal, easier way to do this is simply
 #import "YourTarget-Swift.h"
 which refers to the header automatically generated by Xcode.
 But we don't know what YourTarget is. */
@interface SSYMOCManager (Swift)
+ (BOOL)migrateIfNeededWithUrl:(NSURL*)url
                      momdName:(NSString*)momdName
                         error:(NSError**)error_p;
@end

static NSManagedObjectContext* static_pasteboardManagedObjectContext = nil;


NSString* const constKeyMOC = @"moc" ;
NSString* const constKeyOwner = @"owr" ;
NSString* const constKeyStoreUrl = @"sturl" ;

#if 0
#define SIMULATE_BAD_STORE 1
static BOOL didSimulateBadStoreOnce = NO;
#endif

// This is a singleton, but not a "true singletons", because
// I didn't bother to override
//    +allocWithZone:
//    -copyWithZone: 
//    -retain
//    -retainCount
//    -release
//    -autorelease
static SSYMOCManager* sharedMOCManager = nil ;


@interface SSYMOCManager (PrivateHeader)

@end

@implementation SSYMOCManager

+ (SSYMOCManager*)sharedMOCManager {
    @synchronized(self) {
        if (!sharedMOCManager) {
            sharedMOCManager = [[self alloc] init] ; 
        }
    }
	
	// No autorelease.  This sticks around forever.
    return sharedMOCManager ;
}

- (NSMutableDictionary*)inMemoryMOCDics {
	if (!inMemoryMOCDics) {
		inMemoryMOCDics = [[NSMutableDictionary alloc] init] ;
	}
	
	return inMemoryMOCDics ;
}

- (NSMutableDictionary*)sqliteMOCDics {
	if (!sqliteMOCDics) {
		sqliteMOCDics = [[NSMutableDictionary alloc] init] ;
	}
	
	return sqliteMOCDics ;
}

- (NSMutableDictionary*)docMOCDics {
	if (!docMOCDics) {
		docMOCDics = [[NSMutableDictionary alloc] init] ;
	}
	
	return docMOCDics ;
}

- (void)attemptRecoveryFromError:(NSError*)error
					 recoveryOption:(NSUInteger)recoveryOption
						delegate:(id)dontUseThis
			  didRecoverSelector:(SEL)useInvocationFromInfoDicInstead
					 contextInfo:(void*)contextInfo {
	error = [error deepestRecoverableError] ;
	switch(recoveryOption) {
		case NSAlertFirstButtonReturn:;
			// "Move"
            NSURL* url = [[error userInfo] objectForKey:constKeyStoreUrl];
            [[self class] removeStoreAtUrl:url
                                   tildefy:YES];

			// Since the old corrupted file is gone, +[SSYMOCManager addPersistentStoreWithType:::::]
			// will create a new file the next time it is invoked.  Problem should be solved.
			break ;
	}
}

+ (NSString*)directoryOfSqliteMOCs {
    NSBundle* mainAppBundle = [NSBundle mainAppBundle] ;
    return [mainAppBundle applicationSupportPathForMotherApp] ;
}

+ (NSURL*)sqliteStoreURLWithIdentifier:(NSString*)identifier {
	NSString* filename ;
	if (!identifier) {
		identifier = @"Shared" ;
	}
	filename = [identifier stringByAppendingPathExtension:SSYManagedObjectContextPathExtensionForSqliteStores] ;
	NSString* path = [[self directoryOfSqliteMOCs] stringByAppendingPathComponent:filename] ;
    NSURL* url = nil ;
    if (path) {
        // Above if() was added in BookMacster 1.19 to eliminate crash in case
        // the app's Application Suppport folder is trashed while Worker is
        // watching one or more files in it for changes.
        url = [NSURL fileURLWithPath:path] ;
    }

	return url ;
}

+ (BOOL)sqliteStoreExistsForIdentifier:(NSString*)identifier {
	NSURL* url = [self sqliteStoreURLWithIdentifier:identifier] ;
	return [[NSFileManager defaultManager] fileExistsAtPath:[url path]] ;
}

+ (void)removeStoreAtUrl:(NSURL*)url
                 tildefy:(BOOL)tildefy {
    /* In some cases, you may want to keep all tildefied files, adding more
     tildes, for example, Foo~~.sql.  I have written code which does that
     for document files, but we do not use it here.  Prior prior tildefied
     files are removed. */

    /* We ignore any errors produced by File Manager calls in this method,
     because it is expected that an indicated file may not always exist, for
     various reasons.  In particular, if the subject file Foo.sql is really bad,
     sometimes Core Data may have already moved it to Foo.unreadable.sql.  */

    NSString* originalPath = [url path];
    NSString* originalShmPath = [originalPath stringByAppendingString:@"-shm"];
    NSString* originalWalPath = [originalPath stringByAppendingString:@"-wal"];
    
    if (tildefy) {
        NSString* tildefiedPath = [originalPath tildefiedPath];
        NSString* tildefiedShmPath = [originalShmPath tildefiedPath];
        NSString* tildefiedWalPath = [originalWalPath tildefiedPath];

        /* -moveItemAtPath::: will fail if there happens to already be a
         file at the destination, so we clear those out first. */
        [[NSFileManager defaultManager] removeItemAtPath:tildefiedPath
                                                   error:NULL];
        [[NSFileManager defaultManager] removeItemAtPath:tildefiedShmPath
                                                   error:NULL];
        [[NSFileManager defaultManager] removeItemAtPath:tildefiedWalPath
                                                   error:NULL];

        [[NSFileManager defaultManager] moveItemAtPath:originalPath
                                                toPath:tildefiedPath
                                                 error:NULL];
        [[NSFileManager defaultManager] moveItemAtPath:originalShmPath
                                                toPath:tildefiedShmPath
                                                 error:NULL] ;
        [[NSFileManager defaultManager] moveItemAtPath:originalWalPath
                                                toPath:tildefiedWalPath
                                                 error:NULL];
    } else {
        [[NSFileManager defaultManager] removeItemAtPath:originalPath
                                                   error:NULL];
        [[NSFileManager defaultManager] removeItemAtPath:originalShmPath
                                                   error:NULL];
        [[NSFileManager defaultManager] removeItemAtPath:originalWalPath
                                                   error:NULL];
    }
}

+ (NSPersistentStoreCoordinator*)persistentStoreCoordinatorType:(NSString*)storeType
                                                     identifier:(NSString*)identifier
                                                       momdName:(NSString*)momdName
                                                        options:(NSDictionary*)options
                                           nukeAndPaveIfCorrupt:(BOOL)nukeAndPaveIfCorrupt
                                                        error_p:(NSError**)error_p {
    NSPersistentStore* persistentStore = nil ;
    
    NSArray* bundles = [NSArray arrayWithObject:[NSBundle mainAppBundle]] ;
    NSManagedObjectModel* mergedMOM = [NSManagedObjectModel mergedModelFromBundles:bundles] ;
    NSPersistentStoreCoordinator* newPSC = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:mergedMOM] ;
    
    if ([storeType isEqualToString:NSSQLiteStoreType]) {
        NSURL* url = [self sqliteStoreURLWithIdentifier:identifier] ;
        // i.e file://localhost/Users/jk/Library/Application%20Support/BookMacster/BookMacster.sql
        
        NSFileManager* fm = [NSFileManager defaultManager] ;
        BOOL ok = YES ;
        
        // An undocumented fact about addPersistentStoreWithType:configuration:URL:options:error:
        // is that if the parent folder does not exist, the method will fail to create a
        // persistent store with no explanation.  So we make sure it exists
        NSString* parentPath = [[url path] stringByDeletingLastPathComponent] ;
        
        if (!parentPath) {
            ok = NO ;
        }
        
        BOOL isDirectory = NO ;
        BOOL fileExists = NO ;
        
        if (ok) {
            [fm fileExistsAtPath:parentPath isDirectory:&isDirectory] ;
            if (fileExists && !isDirectory) {
                // Someone put a file where our directory should be
                ok = [fm removeItemAtPath:parentPath
                                    error:error_p] ;
            }
        }
        
        NSError* error = nil ;
        if (ok && ((fileExists && !isDirectory) || !fileExists)) {
            // Create parent directory
            ok = [fm createDirectoryAtPath:parentPath
               withIntermediateDirectories:YES
                                attributes:nil
                                     error:&error] ;
        }
        
        if (!ok) {
            NSString* msg = [NSString stringWithFormat:
                             @"Could not create directory at %@",
                             parentPath] ;
            error = [SSYMakeError(95745, msg) errorByAddingUnderlyingError:error] ;
            NSLog(@"%@", error) ;
            if (error_p) {
                *error_p = error ;
            }
        }
        
        if (ok) {
            ok = [self migrateIfNeededWithUrl:url
                                     momdName:momdName
                                        error:&error];
            
            if (ok) {
                // Add persistent store to it
                persistentStore = [newPSC addPersistentStoreWithType:NSSQLiteStoreType
                                                       configuration:nil
                                                                 URL:url
                                                             options:options
                                                               error:error_p] ;
#if SIMULATE_BAD_STORE
                if (!didSimulateBadStoreOnce) {
                    persistentStore = nil ;
                    NSString* simulatedErrorDescription = [NSString stringWithFormat:
                                                           @"Can't use this stinkin' store at\n%@",
                                                           url.path];
                    *error_p = SSYMakeError(12345, simulatedErrorDescription) ;
                    NSLog(@"61745: Simulating bad store at %@", url.path);
                    didSimulateBadStoreOnce = YES;
                }
#endif
                if (!persistentStore) {
                    BOOL fileExists = [fm fileExistsAtPath:[url path]] ;
                    if (fileExists) {
                        if (nukeAndPaveIfCorrupt) {
                            // If we did not get a store but file exists, must be a corrupt file or store.
                            [self removeStoreAtUrl:url
                                           tildefy:NO];
                            persistentStore = [newPSC addPersistentStoreWithType:NSSQLiteStoreType
                                                                   configuration:nil
                                                                             URL:url
                                                                         options:options
                                                                           error:error_p] ;
                        }
                        
                        if (!persistentStore) {
                            if (error_p) {
                                NSString* msg = [NSString stringWithFormat:@"Click 'Move' to move the unreadable database\n%@\nto your desktop and start a new database.  The item properties in your old database will not be available to %@.",
                                                 [url path],
                                                 [[NSBundle mainAppBundle] objectForInfoDictionaryKey:@"CFBundleExecutable"]] ;
                                // We used CFBundleExecutable instead of CFBundleName to get an unlocalized app name.
                                *error_p = [*error_p errorByAddingLocalizedRecoverySuggestion:msg] ;
                                NSArray* recoveryOptions = [NSArray arrayWithObjects:
                                                            [NSString localize:@"move"],
                                                            [NSString localize:@"cancel"],
                                                            nil] ;
                                *error_p = [*error_p errorByAddingLocalizedRecoveryOptions:recoveryOptions] ;
                                *error_p = [*error_p errorByAddingRecoveryAttempter:[self sharedMOCManager]] ;
                                *error_p = [*error_p errorByAddingUserInfoObject:url
                                                                          forKey:constKeyStoreUrl] ;
                            }
                        }
                    }
                    else {
                        NSString* msg = [NSString stringWithFormat:
                                         @"Could not create persistent store file at path %@",
                                         [url absoluteString]] ;
                        NSLog(@"%@", msg) ;
                        if (error_p) {
                            *error_p = SSYMakeError(51298, msg) ;
                        }
                    }
                }
            }
        }
    }
    else if ([storeType isEqualToString:NSInMemoryStoreType]) {
        persistentStore = [newPSC addPersistentStoreWithType:NSInMemoryStoreType
                                               configuration:nil
                                                         URL:nil
                                                     options:options
                                                       error:error_p] ;
        
        if (!persistentStore) {
            NSLog(@"Internal Error 535-1498.  Failed to create inMemory persistent store") ;
        }
    }
    
    if (!persistentStore) {
        // If persistentStore could not be added, we don't want the
        // newPSC to be returned because it won't work
        [newPSC release] ;
        newPSC = nil ;
    }
    
    return [newPSC autorelease] ;
}

- (NSManagedObjectContext*)managedObjectContextType:(NSString*)type
											  owner:(id)owner_
										 identifier:(NSString*)identifier
										   momdName:(NSString*)momdName
                                            options:(NSDictionary*)options
                               nukeAndPaveIfCorrupt:(BOOL)nukeAndPaveIfCorrupt
											error_p:(NSError**)error_p {
	NSManagedObjectContext* managedObjectContext = nil ;
    NSMutableDictionary* mocDics = nil ;
    if ([type isEqualToString:NSInMemoryStoreType]) {
		mocDics = [self inMemoryMOCDics] ;
	}
	else if ([type isEqualToString:NSSQLiteStoreType]) {
		mocDics = [self sqliteMOCDics] ;
	}

	if (!identifier) {
		identifier = @"CommonData" ;
	}
	
	NSDictionary* mocDic = [mocDics objectForKey:identifier] ;
	managedObjectContext = [mocDic objectForKey:constKeyMOC] ;
	
	if (!managedObjectContext) {
		NSPersistentStoreCoordinator* coordinator = [[self class] persistentStoreCoordinatorType:type
																					  identifier:identifier
																						momdName:momdName
                                                                                         options:options
                                                                            nukeAndPaveIfCorrupt:nukeAndPaveIfCorrupt
																						 error_p:error_p] ;
		if (coordinator) {
            managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType] ;
            // NSLog(@"Created for %@ moc %p on thread %p isMain=%hhd", identifier, managedObjectContext, [NSThread currentThread], [[NSThread currentThread] isMainThread]) ;
			[managedObjectContext setPersistentStoreCoordinator:coordinator] ;
			if (!owner_) {
				// A no-owner moc is a "cheap" moc.
				[managedObjectContext setUndoManager:nil] ;
				
				// Give it the default owner
				owner_ = NSApp ;
			}
			NSDictionary* mocDic = [NSDictionary dictionaryWithObjectsAndKeys:
									managedObjectContext, constKeyMOC,
									owner_, constKeyOwner,
									nil] ;
			[mocDics setObject:mocDic
						forKey:identifier] ;
			
			[managedObjectContext release] ; // balances +alloc, above
            ;
		}
	}
	
	return managedObjectContext ;
}

+ (void)registerOwnerDocument:(BSManagedDocument*)document
	   ofManagedObjectContext:(NSManagedObjectContext*)managedObjectContext {
    @synchronized(self) {
        NSMutableDictionary* mocDics = [[self sharedMOCManager] docMOCDics] ;

        // Check for an existing entry for this owner.  To make sure we
        // replace it, we'll use the same key.
        NSNumber* key = nil ;
        for (NSNumber* aKey in mocDics) {
            NSDictionary* mocDic = [mocDics objectForKey:aKey] ;
            if ([mocDic objectForKey:constKeyOwner] == document) {
                key = aKey ;
                break ;
            }
        }

        if (key == nil) {
            // We need an arbitrary but unique key
            NSInteger highestUsed = 0 ;
            for (NSNumber* number in mocDics) {
                highestUsed = MAX(highestUsed, [number integerValue]) ;
            }
            key = [NSNumber numberWithInteger:(highestUsed+1)] ;
        }

        NSDictionary* mocDic = [NSDictionary dictionaryWithObjectsAndKeys:
                                managedObjectContext, constKeyMOC,
                                document, constKeyOwner,
                                nil] ;

        [mocDics setObject:mocDic
                    forKey:key] ;
    }
}


- (id)ownerOfManagedObjectContext:(NSManagedObjectContext*)managedObjectContext
					 inDictionary:(NSDictionary*)dictionary {
	for (NSString* identifier in dictionary) {
		NSDictionary* mocDic = [dictionary objectForKey:identifier] ;
		if ([mocDic objectForKey:constKeyMOC] == managedObjectContext) {
			return [mocDic objectForKey:constKeyOwner] ;
		}
	}
	
	return nil ;
}

- (id)ownerOfManagedObjectContext:(NSManagedObjectContext*)managedObjectContext {
    id answer = nil;
    @synchronized(self) {
        answer = [self ownerOfManagedObjectContext:managedObjectContext
                                      inDictionary:[self inMemoryMOCDics]] ;
        
        if (!answer) {
            answer = [self ownerOfManagedObjectContext:managedObjectContext
                                          inDictionary:[self sqliteMOCDics]] ;
        }

        if (!answer) {
            answer = [self ownerOfManagedObjectContext:managedObjectContext
                                          inDictionary:[self docMOCDics]] ;
        }

        [answer retain];
    }

    [answer autorelease];

	return answer ;
}

- (void)destroyManagedObjectContextWithIdentifier:(NSString*)identifier {
    @synchronized(self) {
        if (identifier) {
            [[self inMemoryMOCDics] removeObjectForKey:identifier] ;
            [[self sqliteMOCDics] removeObjectForKey:identifier] ;
            [[self docMOCDics] removeObjectForKey:identifier] ;
        }
    }
}

- (BOOL)destroyManagedObjectContext:(NSManagedObjectContext*)managedObjectContext
					   inDictionary:(NSMutableDictionary*)dictionary {
	NSString* removeeIdentifier = nil ;
	for (NSString* identifier in dictionary) {
		NSDictionary* mocDic = [dictionary objectForKey:identifier] ;
		if ([mocDic objectForKey:constKeyMOC] == managedObjectContext) {
			removeeIdentifier = identifier ;
			break ;
		}
	}
	
	if (removeeIdentifier) {
		[dictionary removeObjectForKey:removeeIdentifier] ;
	}

	return (removeeIdentifier != nil) ;
}	

- (BOOL)destroyManagedObjectContext:(NSManagedObjectContext*)managedObjectContext {
    BOOL didDo = NO ;
    @synchronized(self) {
        didDo = [self destroyManagedObjectContext:managedObjectContext
                                     inDictionary:[self inMemoryMOCDics]] ;
        if (!didDo) {
            didDo = [self destroyManagedObjectContext:managedObjectContext
                                         inDictionary:[self sqliteMOCDics]] ;
        }

        if (!didDo) {
            didDo = [self destroyManagedObjectContext:managedObjectContext
                                         inDictionary:[self docMOCDics]] ;
        }
    }

	return didDo ;
}

- (void) dealloc {
    [inMemoryMOCDics release] ;
    [sqliteMOCDics release] ;
    [docMOCDics release] ;
	
	[super dealloc] ;
}

+ (NSManagedObjectContext*)managedObjectContextType:(NSString*)type
											  owner:(id)owner
										 identifier:(NSString*)identifier
										   momdName:(NSString*)momdName
                               nukeAndPaveIfCorrupt:(BOOL)nukeAndPaveIfCorrupt
                                            error_p:(NSError**)error_p {
    NSDictionary* options = nil ;

	NSManagedObjectContext* moc = [[self sharedMOCManager] managedObjectContextType:type
																			  owner:owner
																		 identifier:identifier
																		   momdName:momdName
                                                                            options:options
                                                               nukeAndPaveIfCorrupt:nukeAndPaveIfCorrupt
																			error_p:error_p] ;
	return moc ;
}

+ (id)ownerOfManagedObjectContext:(NSManagedObjectContext*)managedObjectContext {
	return [[self sharedMOCManager] ownerOfManagedObjectContext:managedObjectContext] ;
}

+ (BOOL)destroyManagedObjectContext:(NSManagedObjectContext*)managedObjectContext {
	return [[self sharedMOCManager] destroyManagedObjectContext:managedObjectContext] ;
}

+ (void)destroyManagedObjectContextWithIdentifier:(NSString*)identifier {
	[[self sharedMOCManager] destroyManagedObjectContextWithIdentifier:identifier] ;
}

+ (void)removeSqliteStoreForIdentifier:(NSString*)identifier {
	NSURL* url = [self sqliteStoreURLWithIdentifier:identifier];
    [self removeStoreAtUrl:url
                   tildefy:NO];
}


+ (BOOL)moc:(NSManagedObjectContext*)moc
	isInDic:(NSDictionary*)dic {
	// The outer key is the serial number assigned in -registerOwnerDocument::
	// The pointer to the moc is a value for the inner key constKeyMoc
	for (NSNumber* number in dic) {
		if ([[dic objectForKey:number] objectForKey:constKeyMOC] == moc) {
			return YES ;
		}
	}
	
	return NO ;
}

+ (BOOL)isInMemoryMOC:(NSManagedObjectContext*)moc {
	return [self moc:moc
			 isInDic:[[self sharedMOCManager] inMemoryMOCDics]] ;
}

+ (BOOL)isSqliteMOC:(NSManagedObjectContext*)moc {
	return [self moc:moc
			 isInDic:[[self sharedMOCManager] sqliteMOCDics]] ;
}

+ (BOOL)isDocMOC:(NSManagedObjectContext*)moc {
    BOOL answer = NO;
    @synchronized(self) {
        answer = [self moc:moc
                   isInDic:[[self sharedMOCManager] docMOCDics]] ;
    }

    return answer;
}

+ (NSManagedObjectContext*)scratchManagedObjectContext {
    NSManagedObjectContextConcurrencyType concurrencyType = [[NSThread currentThread] isMainThread] ? NSMainQueueConcurrencyType : NSPrivateQueueConcurrencyType;
    NSManagedObjectContext* scratchMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:concurrencyType];
    scratchMOC.undoManager = nil;
    NSArray* bundles = [NSArray arrayWithObject:[NSBundle mainAppBundle]] ;
    NSManagedObjectModel* mergedMOM = [NSManagedObjectModel mergedModelFromBundles:bundles] ;
    NSPersistentStoreCoordinator* scratchPSC = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:mergedMOM] ;
    NSError* unlikelyError = nil;
    [scratchPSC addPersistentStoreWithType:NSInMemoryStoreType
                             configuration:nil
                                       URL:nil
                                   options:0
                                     error:&unlikelyError];
    NSAssert(unlikelyError == nil, @"Internal Error 874-4408 %@", unlikelyError);
    scratchMOC.persistentStoreCoordinator = scratchPSC;
    [scratchPSC release];
    [scratchMOC autorelease];

    return scratchMOC;
}

+ (NSManagedObjectContext*)pasteboardManagedObjectContext {
    @synchronized(self) {
        if (!static_pasteboardManagedObjectContext) {
            static_pasteboardManagedObjectContext = [self scratchManagedObjectContext] ;
#if !__has_feature(objc_arc)
            [static_pasteboardManagedObjectContext retain];
#endif
        }
    }

    // No autorelease.  This sticks around forever.
    return static_pasteboardManagedObjectContext ;
}

+ (NSArray <NSManagedObject*>*)deepCopiesForPasteboardObjects:(NSArray <NSManagedObject*> *)objects
                                  doNotEnterRelationshipNames:(NSSet*)relationshipNames {
    NSMutableArray* copies = [NSMutableArray new];
    for (NSManagedObject* object in objects) {
        NSManagedObject* copy = [object deepCopyInManagedObjectContext:[self pasteboardManagedObjectContext]
                                           doNotEnterRelationshipNames:relationshipNames];
        [copies addObject:copy];
    }

    NSArray <NSManagedObject*> * answer = [copies copy];
#if !__has_feature(objc_arc)
    [copies release];
    [answer autorelease];
#endif

    return answer;
}

#if DEBUG
+ (void)logDebugCurrentSqliteMocs {
	NSDictionary* sqliteMOCDics = [[self sharedMOCManager] sqliteMOCDics] ;
	NSLog(@"Listing of SSYManaged SQLite MOCs") ;
	for (NSString* identifier in sqliteMOCDics) {
		NSManagedObjectContext* moc = [[sqliteMOCDics objectForKey:identifier] objectForKey:constKeyMOC] ;
		id owner = [[sqliteMOCDics objectForKey:identifier] objectForKey:constKeyOwner] ;
		NSCountedSet* stats = [[NSCountedSet alloc] init] ;
		for (NSManagedObject* object in [moc registeredObjects]) {
			NSString* entityName = [[object entity] name] ;
			[stats addObject:entityName] ;
		}
		NSLog(@"   moc %p owned by %@ at %@\n      Object Counts: %@",
			  moc,
			  [owner shortDescription],
			  [[[[moc store1] URL] path] lastPathComponent],
			  [stats shortDescription]) ;
		[stats release] ;
	} 
}
#endif
@end

// Note 1.
// Because our method +persistentStoreCoordinatorType:::::: always creates
// a new persistent store coordinator and always adds exactly one persistent
// store to it, we can just grab its first (and only) store.
